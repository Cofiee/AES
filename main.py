import PySimpleGUI as sg
import numpy as np

# Nb liczba kolumn stanu to 4
# Nk długość klucza w 32 bitowych słowach dla 128bit długość to 4
# Nr liczba rund szyfrowania dla klucza 128bit to 10 (128 -> 10, 192 -> 12, 256 -> 14)

sbox = [
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
]
inv_sbox = [
    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
]
galois28 = [
    0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
    0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
    0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
    0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
    0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
    0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
    0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
    0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
    0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
    0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
    0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
    0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
    0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
    0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
    0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
    0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5
]
rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]


def main():
    layout = [
        [sg.Text("klucz:"), sg.InputText(key='key32')],
        [sg.Text("wiadomość:"), sg.Multiline(size=(30, 5), key='message')],
        [sg.Text("szyfrogram:")],
        [sg.Multiline(size=(30, 5), key='output', disabled=True)],
        [sg.Button("Szyfruj"), sg.Button("Odszyfruj"), sg.Button("Wyczyść")]
    ]

    window = sg.Window(title="AES", layout=layout, margins=(100, 50))

    while True:
        event, values = window.read()
        #message = "3243F6A8885A308D313198A2E0370734"
        # message = "Kurwa mac"
        # key = "2B7E151628AED2A6ABF7158809CF4F3C"
        # cipher = "1167dc0ae4563b4d6cf096d98ee6e240"

        if event == "Szyfruj":
            message = values['message']
            message = message.lower()
            message = message.encode().hex()
            message = fill_blocks_to_32(message)
            key = values['key32']
            cipher_ints = encrypt(message, key)
            cipher_hex_str = bytearray(cipher_ints).hex()
            window['output'].update(value=cipher_hex_str)
            #debug

        elif event == "Odszyfruj":
            cipher = values['message']
            cipher = cipher.lower()
            key = values['key32']
            plain_text_ints = decrypt(cipher, key)
            plain_text_hex_str = bytearray(plain_text_ints).hex()
            plain_text = bytes.fromhex(plain_text_hex_str).decode("ascii")
            window['output'].update(value=plain_text)

        elif event == "Wyczyśc":
            pass
        elif event == sg.WIN_CLOSED:
            break


def fill_blocks_to_32(message):
    if diff := len(message) % 32:
        message += '20' * ((32 - diff) // 2) # fill spaces
    return message


def encrypt(message: str, key: str) -> str:
    # debug
    # message = "3243F6A8885A308D313198A2E0370734"
    # key = "2B7E151628AED2A6ABF7158809CF4F3C"

    state = initialize_state(message)
    print("Initialize matrix: ")
    print([hex(i) for i in state])

    key_schedule = key_expansion(key)
    print("Initial key: ")
    print([hex(i) for i in key_schedule[0]])

    state = add_round_key(state, key_schedule[0])
    print("After key addition: ")
    print([hex(i) for i in state])

    for i in range(1, 10):
        state = byte_substitution(state)
        print("After byte sub: ")
        print([hex(i) for i in state])
        state = shift_rows(state)
        print("After row Shift: ")
        print([hex(i) for i in state])
        state = mix_columns(state)
        print("After mix column: ")
        print([hex(i) for i in state])
        print("Round key: ")
        print([hex(i) for i in key_schedule[i]])
        state = add_round_key(state, key_schedule[i])
        print("After key addition: ")
        print([hex(i) for i in state])

    state = byte_substitution(state)
    print("After byte sub: ")
    print([hex(i) for i in state])
    state = shift_rows(state)
    print("After row Shift: ")
    print([hex(i) for i in state])
    print("Round key: ")
    print([hex(i) for i in key_schedule[i]])
    state = add_round_key(state, key_schedule[10])
    print("After key addition: ")
    print([hex(i) for i in state])
    return state


def decrypt(cipher, key):
    # cipher = "373837cca0140f8a9cc15d3899e0aa9d".upper()
    # key = "2B7E151628AED2A6ABF7158809CF4F3C"

    state = initialize_state(cipher)
    key_schedule = key_expansion(key)

    state = add_round_key(state, key_schedule[10])
    state = inv_shift_rows(state)
    state = inv_byte_substitution(state)
    for i in range(9, 0, -1):
        state = add_round_key(state, key_schedule[i])
        state = inv_mix_columns(state)
        state = inv_shift_rows(state)
        state = inv_byte_substitution(state)

    state = add_round_key(state, key_schedule[0])
    print([hex(i) for i in state])
    return state


def initialize_state(plain_text):
    state = []
    while plain_text:
        state.append(int(plain_text[0:2], 16))
        plain_text = plain_text[2:]
    return state


def rotation(arr):
    first = arr[0]
    arr = arr[1:]
    arr.append(first)
    return arr


def xor(v1, v2):
    return v1 ^ v2


def key_expansion(key) -> list:
    # key_schedule = [int(c, 16) for c in key]
    expanded_key = []
    while key:
        expanded_key.append(int(key[0:2], 16))
        key = key[2:]

    round_num = 4
    tmp = [0] * 4
    while round_num < 44:
        from_4_rounds_ago = expanded_key[4 * (round_num - 4): 4 * (round_num - 3)]
        prev_round = expanded_key[4 * (round_num - 1): 4 * round_num]
        if round_num % 4 == 0:
            prev_round = byte_substitution(rotation(prev_round))
            for i in range(0, 4):
                tmp[i] = xor(from_4_rounds_ago[i], prev_round[i])
            tmp[0] = xor(tmp[0], rc(round_num // 4))
        else:
            for i in range(0, 4):
                tmp[i] = xor(from_4_rounds_ago[i], prev_round[i])
        expanded_key = expanded_key + tmp
        round_num += 1
    return [expanded_key[i: i + 16] for i in range(0, len(expanded_key), 16)]


def rc(index):
    if index <= 1:
        return 1
    tmp_num = rc(index - 1)
    return galois28[tmp_num]


def add_round_key(state, key_schedule) -> list:
    new_state = []
    for i in range(0, 16):
        new_state.append(xor(key_schedule[i], state[i]))
    return new_state


def byte_substitution(state) -> list:
    new_state = []
    for byte in state:
        new_state.append(sbox[byte])
    return new_state


def inv_byte_substitution(state) -> list:
    new_state = []
    for byte in state:
        new_state.append(inv_sbox[byte])
    return new_state


def shift_rows(state) -> list:
    new_state = [None] * 16
    new_state[0] = state[0]
    new_state[1] = state[5]
    new_state[2] = state[10]
    new_state[3] = state[15]
    new_state[4] = state[4]
    new_state[5] = state[9]
    new_state[6] = state[14]
    new_state[7] = state[3]
    new_state[8] = state[8]
    new_state[9] = state[13]
    new_state[10] = state[2]
    new_state[11] = state[7]
    new_state[12] = state[12]
    new_state[13] = state[1]
    new_state[14] = state[6]
    new_state[15] = state[11]
    return new_state


def inv_shift_rows(state) -> list:
    new_state = [None] * 16
    new_state[0] = state[0]
    new_state[5] = state[1]
    new_state[10] = state[2]
    new_state[15] = state[3]
    new_state[4] = state[4]
    new_state[9] = state[5]
    new_state[14] = state[6]
    new_state[3] = state[7]
    new_state[8] = state[8]
    new_state[13] = state[9]
    new_state[2] = state[10]
    new_state[7] = state[11]
    new_state[12] = state[12]
    new_state[1] = state[13]
    new_state[6] = state[14]
    new_state[11] = state[15]
    return new_state


def mix_columns(state):
    tmp = [0] * len(state)
    for i in range(0, 4):
        tmp_col = [state[i], state[4 + i], state[8 + i], state[12 + i]]
        tmp_col = mix_column(tmp_col)
        tmp[i] = tmp_col[0]
        tmp[4 + i] = tmp_col[1]
        tmp[8 + i] = tmp_col[2]
        tmp[12 + i] = tmp_col[3]
    return tmp


def inv_mix_columns(state) -> list:
    tmp = [0] * len(state)
    for i in range(0, 4):
        tmp_col = [state[i], state[4 + i], state[8 + i], state[12 + i]]
        tmp_col = inv_mix_column(tmp_col)
        tmp[i] = tmp_col[0]
        tmp[4 + i] = tmp_col[1]
        tmp[8 + i] = tmp_col[2]
        tmp[12 + i] = tmp_col[3]
    return tmp


def mix_column(col):
    tmp_col = [0] * 4
    tmp_col[0] = mult(2, col[0]) ^ mult(3, col[1]) ^ col[2] ^ col[3]
    tmp_col[1] = col[0] ^ mult(2, col[1]) ^ mult(3, col[2]) ^ col[3]
    tmp_col[2] = col[0] ^ col[1] ^ mult(2, col[2]) ^ mult(3, col[3])
    tmp_col[3] = mult(3, col[0]) ^ col[1] ^ col[2] ^ mult(2, col[3])
    return tmp_col


def inv_mix_column(col):
    tmp_col = [0] * 4
    tmp_col[0] = mult(14, col[0]) ^ mult(11, col[1]) ^ mult(13, col[2]) ^ mult(9, col[3])
    tmp_col[1] = mult(9, col[0]) ^ mult(14, col[1]) ^ mult(11, col[2]) ^ mult(13, col[3])
    tmp_col[2] = mult(13, col[0]) ^ mult(9, col[1]) ^ mult(14, col[2]) ^ mult(11, col[3])
    tmp_col[3] = mult(11, col[0]) ^ mult(13, col[1]) ^ mult(9, col[2]) ^ mult(14, col[3])
    return tmp_col


# def mult(num2, num1):  # Galois zmienic na lookup
#     p = 0x00
#     for i in range(0, 8):
#         if (num2 & 1) != 0:
#             p ^= num1
#
#         hi_bit_set = (num1 & 0x80) != 0
#         num1 <<= 1
#         if hi_bit_set:
#             num1 = num1 ^ 0x1b  # x^8 + x^4 + x^3 + x + 1
#         num2 >>= 1
#     return p


def mult(b, a):
    p = 0
    hi_bit_set = 0
    for i in range(8):
        if b & 1 == 1: p ^= a
        hi_bit_set = a & 0x80
        a <<= 1
        if hi_bit_set == 0x80: a ^= 0x1b
        b >>= 1
    return p % 256


if __name__ == '__main__':
    main()

"""
Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)]) begin
byte state[4,Nb]
state = in
AddRoundKey(state, w[0, Nb-1])
for round = 1 step 1 to Nr–1
    SubBytes(state)
    ShiftRows(state)
    MixColumns(state)
    AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
end for
SubBytes(state)
ShiftRows(state)
AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
out = state
end
"""
